import logging
import multiprocessing as mp
import os
import signal
from multiprocessing.context import SpawnProcess
from socket import socket
from types import FrameType
from typing import Callable, List, Optional, Protocol

from uvicorn.config import Config
from uvicorn.subprocess import get_subprocess

logger = logging.getLogger("uvicorn.error")


class Target(Protocol):
    def __call__(self, sockets: Optional[List[socket]] = None) -> None:
        ...


class ProcessManager:
    STARTUP_FAILED = 3
    SIGNALS = {
        getattr(signal, f"SIG{sig.upper()}"): sig
        for sig in (
            "abrt",  # Abort signal from abort(3)
            "hup",  # Hangup signal generated by terminal close.
            "quit",  # Quit signal generated by terminal close.
            "int",  # Interrupt signal generated by Ctrl+C
            "term",  # Termination signal
            "usr1",  # User-defined signal 1
            "usr2",  # User-defined signal 2
            "winch",  # Window size change signal
            "chld",  # Child process terminated, stopped, or continued
        )
    }

    def __init__(self, config: Config, target: Target, sockets: List[socket]) -> None:
        self.config = config
        self.target = target
        self.sockets = sockets
        self.processes: List[SpawnProcess] = []
        self.sig_queue = mp.Queue()

    def run(self) -> None:
        self.start()

        try:
            self.spawn_processes()

            while True:
                sig = self.sig_queue.get()
                handler = self.signal_handler(sig)
                if handler is None:
                    print("Unhandled signal: %s", self.SIGNALS.get(sig))
                else:
                    handler()
        except Exception as exc:
            print(exc)

        print("Shutting down manager!")

    def start(self) -> None:
        self.pid = os.getpid()
        print(self.pid)

        self.init_signals()

    def spawn_processes(self) -> None:
        for _ in range(self.config.workers - len(self.processes)):
            self.spawn_process()
            # NOTE: Random delay is necessary?

    def spawn_process(self) -> None:
        process = get_subprocess(self.config, target=self.target, sockets=self.sockets)
        process.start()
        self.processes.append(process)

    def init_signals(self) -> None:
        for s in self.SIGNALS.keys():
            signal.signal(s, self._signal)
        signal.signal(signal.SIGCHLD, self.handle_chld)

    def _signal(self, sig: signal.Signals, frame: FrameType) -> None:
        print("Master got signal: ", self.SIGNALS.get(sig))
        self.sig_queue.put(sig)

    def shutdown(self) -> None:
        for process in self.processes:
            process.terminate()

        for process in self.processes:
            process.join()

        for sock in self.sockets:
            sock.close()

        raise StopIteration

    handle_int = shutdown
    handle_term = shutdown

    def handle_chld(self, sig: signal.Signals, frame: FrameType) -> None:
        ...

    def signal_handler(self, sig: signal.Signals) -> Optional[Callable[..., None]]:
        sig_name = self.SIGNALS.get(sig)
        return getattr(self, f"handle_{sig_name}", None)
