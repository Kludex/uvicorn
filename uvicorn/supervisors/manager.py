import logging
import multiprocessing as mp
import os
import queue
import signal
from multiprocessing.context import SpawnProcess
from socket import socket
from types import FrameType
from typing import Callable, List, Optional, Protocol

from uvicorn.config import Config
from uvicorn.subprocess import get_subprocess

logger = logging.getLogger("uvicorn.error")


class Target(Protocol):
    def __call__(self, sockets: Optional[List[socket]] = None) -> None:
        ...


# def for_all_methods(decorator, *exclude):
#     def decorate(cls):
#         for attr in cls.__dict__:
#             if callable(getattr(cls, attr)) and attr not in exclude:
#                 setattr(cls, attr, decorator(getattr(cls, attr)))
#         return cls

#     return decorate


# def step(func):
#     def wrapper(*args, **kwargs):
#         print(f"{func.__name__} started")
#         return func(*args, **kwargs)

#     return wrapper


# @for_all_methods(step)
class ProcessManager:
    STARTUP_FAILED = 3
    SIGNALS = {
        getattr(signal, f"SIG{sig.upper()}"): sig
        for sig in (
            "abrt",  # Abort signal from abort(3)
            "hup",  # Hangup signal generated by terminal close.
            "quit",  # Quit signal generated by terminal close.
            "int",  # Interrupt signal generated by Ctrl+C
            "term",  # Termination signal
            "usr1",  # User-defined signal 1
            "usr2",  # User-defined signal 2
            "winch",  # Window size change signal
            "chld",  # Child process terminated, stopped, or continued
        )
    }

    def __init__(self, config: Config, target: Target, sockets: List[socket]) -> None:
        self.config = config
        self.target = target
        self.sockets = sockets
        self.processes: List[SpawnProcess] = []
        self.sig_queue = mp.Queue()

    def run(self) -> None:
        self.start()

        try:
            self.spawn_processes()

            while True:
                try:
                    sig = self.sig_queue.get(timeout=0.25)
                except queue.Empty:
                    # self.reap_processes()
                    # self.spawn_processes()
                    continue

                if sig not in self.SIGNALS.keys():
                    logger.info("Ignoring unknown signal: %d", sig)
                    continue

                handler = self.signal_handler(sig)
                if handler is None:
                    logger.info("Unhandled signal: %s", self.SIGNALS.get(sig))
                    continue

                handler()
        except Exception as exc:
            print(repr(exc))

        print("Shutting down manager!")

    def start(self) -> None:
        self.pid = os.getpid()
        logger.info("Started manager process [%d]", self.pid)
        self.init_signals()

    def spawn_processes(self) -> None:
        for _ in range(self.config.workers - len(self.processes)):
            self.spawn_process()

    def spawn_process(self) -> None:
        process = get_subprocess(self.config, target=self.target, sockets=self.sockets)
        process.start()
        self.processes.append(process)

    def init_signals(self) -> None:
        for s in self.SIGNALS.keys():
            signal.signal(s, self._signal)
        signal.signal(signal.SIGCHLD, self.handle_chld)

    def _signal(self, sig: signal.Signals, frame: FrameType) -> None:
        print("Master got signal: ", self.SIGNALS.get(sig))
        self.sig_queue.put(sig)

    def shutdown(self) -> None:
        for process in self.processes:
            process.terminate()

        for process in self.processes:
            process.join()

        for sock in self.sockets:
            sock.close()

        raise StopIteration

    handle_int = shutdown
    handle_term = shutdown

    def handle_chld(self, sig: signal.Signals, frame: FrameType) -> None:
        print("Master got signal: ", self.SIGNALS.get(sig))
        self.reap_processes()

    def signal_handler(self, sig: signal.Signals) -> Optional[Callable[..., None]]:
        sig_name = self.SIGNALS.get(sig)
        return getattr(self, f"handle_{sig_name}", None)

    def reap_processes(self) -> None:
        # NOTE: This is probably not reliable.
        for process in self.processes:
            if process.is_alive():
                print(f"Process {process.pid} is not alive!")
                self.processes.remove(process)
